---
title: Removing Duplicate Entries from Catalog Tables
---

Most Greenplum Database catalog tables have unique indexes on certain columns, including the automatically-generated system columns such as OID.  Indexing or transaction management problems can lead to scenarios where duplicate entries are added to catalog tables.  Follow the steps in this procedure to remove duplicate entries.

## Prerequisites

- If you are using Pivotal Greenplum Database, contact Pivotal Support to resolve any problems discovered with the system catalog. This procedure is intended only for users of the open source Greenplum Database software, or for Pivotal Greenplum Database customers who cannot allow Pivotal Support to directly access their systems or data.

- Use `gpcheckcat` to verify that your system catalog contains duplicate entries. See [Resolving System Catalog Issues](resolve-catalog-issues.html) for a list of common symptoms.

- Perform a full backup of your database before you perform this procedure.

## Procedure

1. As the `gpadmin` user, use the `psql` utility to start a utility-mode connection to the segment where the duplicate catalog entry has been identified.  Enter the command:

    ``` bash
    $ PGOPTIONS='-c gp_session_role=utility' psql -h <segment_host> -p <segment_port> <database_name>
    ```

    Substitute the `<segment_host>`, `<segment_port>`, and `<database_name>` for your system.

2. Use the `\d+` command to list all of the indexes that are available on the affected table. For example, if your troubleshooting process identified duplicate entries on the `pg_class` table, you would enter:

    ``` sql
    gpadmin=# \d+ pg_class
                           Table "pg_catalog.pg_class"
         Column     |   Type    | Modifiers | Storage  | Description
    ----------------+-----------+-----------+----------+-------------
     relname        | name      | not null  | plain    |
     relnamespace   | oid       | not null  | plain    |
     reltype        | oid       | not null  | plain    |
     relowner       | oid       | not null  | plain    |
     relam          | oid       | not null  | plain    |
     relfilenode    | oid       | not null  | plain    |
     reltablespace  | oid       | not null  | plain    |
     relpages       | integer   | not null  | plain    |
     reltuples      | real      | not null  | plain    |
     reltoastrelid  | oid       | not null  | plain    |
     reltoastidxid  | oid       | not null  | plain    |
     relhasindex    | boolean   | not null  | plain    |
     relisshared    | boolean   | not null  | plain    |
     relkind        | "char"    | not null  | plain    |
     relstorage     | "char"    | not null  | plain    |
     relnatts       | smallint  | not null  | plain    |
     relchecks      | smallint  | not null  | plain    |
     reltriggers    | smallint  | not null  | plain    |
     relukeys       | smallint  | not null  | plain    |
     relfkeys       | smallint  | not null  | plain    |
     relrefs        | smallint  | not null  | plain    |
     relhasoids     | boolean   | not null  | plain    |
     relhaspkey     | boolean   | not null  | plain    |
     relhasrules    | boolean   | not null  | plain    |
     relhassubclass | boolean   | not null  | plain    |
     relfrozenxid   | xid       | not null  | plain    |
     relacl         | aclitem[] |           | extended |
     reloptions     | text[]    |           | extended |
    Indexes:
        "pg_class_oid_index" UNIQUE, btree (oid)
        "pg_class_relname_nsp_index" UNIQUE, btree (relname, relnamespace)
    Has OIDs: yes
    ```

3. Record the names of the indexed columns for each available index.  In the above example output for `pg_class`, you would record the `oid` column used in the first index, and the `relname` and `relnamespace` columns used in the second index.  You will need to use each set of indexed columns in separate SQL commands later in the procedure.

4. Disable the system's use of indexes by entering these commands:

    ``` SQL
    gpadmin=# SET enable_indexscan TO off;
    SET
    gpadmin=# SET enable_bitmapscan TO off;
    SET
    ```

    Disabling indexes in this way ensures that later SQL queries will perform a full table scan to reveal duplicate entries. If indexes are enabled, duplicate entries are sometimes not displayed in the query output.

5. Perform this query on each set of indexed columns that you recorded in Step 3, to display the duplicate values that you must correct:

    ``` SQL
    SELECT <columns>, count(*) FROM <table> GROUP BY <columns> HAVING count(*) > 1;
    ```

    Substitute the actual indexed column(s) that you determined in step 3, as well as the affected table name.  The `pg_class` example contains two indexes, and would require two queries. The first query, for the `pg_class_oid_index` index, is:

    ``` SQL
    gpadmin=# SELECT oid, count(*) FROM pg_class GROUP BY oid HAVING count(*) > 1 ;
    ```

    ``` SQL
      oid  | count
    -------+-------
      3233 |     2
    (1 row)
    ```

    The second query, for the `pg_class_relname_nsp_index` index, is:

    ``` SQL
    gpadmin=# SELECT relname, relnamespace, count(*) FROM pg_class GROUP BY relname, relnamespace HAVING count(*) > 1 ;
    ```

    ``` SQL
    gpadmin=# SELECT relname, relnamespace, count(*) FROM pg_class GROUP BY relname, relnamespace HAVING count(*) > 1 ;
                            relname                             | relnamespace | count
----------------------------------------------------------------+--------------+-------
 dup_table                                                      |           11 |     2
    (1 row)
    ```

    Each query displays the column value(s) that contain duplicate entries. For the first

6. **Important:** In order to select the correct row to delete, carefully examine the output produced in this step to determine if other system columns in the duplicate value rows have matching values, or if some of the remaining system columns have different values.

    Use the output from the previous queries (from Step 5) to form a query using syntax:

    ``` SQL
    SELECT xmin, xmax, ctid, oid, * FROM <table> WHERE <column> = <duplicate_value> [AND <column> = <duplicate_value>] [...]
    ```

    The first example query indicated that `oid` value "3233" was duplicated in `pg_class`, so the query is:

    ``` SQL
    SELECT xmin, xmax, ctid, oid, * FROM pg_class WHERE oid = 3233;
    ```

    ``` SQL
     xmin | xmax |  ctid   | oid  |    relname    | relnamespace | reltype | relowner | relam | relfilenode | reltablespace | relpages | reltuples | reltoastrelid | reltoastidxid | relhasindex | relisshared | relkind | relstorage | relnatts | relchecks | reltriggers | relukeys | relfkeys | relrefs | relhasoids | relhaspkey | relhasrules | relhassubclass | relfrozenxid | relacl | reloptions
------+------+---------+------+---------------+--------------+---------+----------+-------+-------------+---------------+----------+-----------+---------------+---------------+-------------+-------------+---------+------------+----------+-----------+-------------+----------+----------+---------+------------+------------+-------------+----------------+--------------+--------+------------
      1 |    0 | (0,104) | 3233 | dup_table     |           99 |   11305 |       10 |     0 |        3233 |             0 |        1 |         0 |             0 |          3234 | t           | f           | t       | h          |        3 |         0 |           0 |        0 |        0 |       0 | f          | f          | f           | f              |          681 |        |
      2 |    0 | (0,112) | 3233 | dup_table     |           99 |   11305 |       10 |     0 |        3233 |             0 |        1 |         0 |             0 |          3234 | t           | f           | t       | h          |        3 |         0 |           0 |        0 |        0 |       0 | f          | f          | f           | f              |          681 |        |   
    (2 rows)
    ```
    
    Ignoring the first three column values, `xmin`, `xmax`, and `oid`, examine the remaining column values.  In the above example, all remaining column values match. In this case, you can select either row (using the `ctid` value) to delete in order to resolve the duplicate entries. Follow the instructions in [FIXME](#fixme).

    The second example query requires that you plug-in the returned values for both `relname` and `relnamespace`, as follows:

    ``` SQL
    SELECT xmin, xmax, ctid, oid, * FROM pg_class WHERE relname = 'dup_table' and relnamespace = 11;
    ```

    ``` SQL
     xmin | xmax |  ctid   | oid  |      relname      | relnamespace | reltype | relowner | relam | relfilenode | reltablespace | relpages | reltuples | reltoastrelid | reltoastidxid | relhasindex | relisshared | relkind | relstorage | relnatts | relchecks | reltriggers | relukeys | relfkeys | relrefs | relhasoids | relhaspkey | relhasrules | relhassubclass | relfrozenxid | relacl | reloptions
------+------+---------+------+-------------------+--------------+---------+----------+-------+-------------+---------------+----------+-----------+---------------+---------------+-------------+-------------+---------+------------+----------+-----------+-------------+----------+----------+---------+------------+------------+-------------+----------------+--------------+--------+------------
    1 |    0 | (0,186) | 2703 | dup_table         |           11 |       0 |       10 |   403 |        2703 |             0 |        2 |       393 |             0 |             0 | f           | f           | i       | h          |        1 |         0 |           0 |        0 |        0 |       0 | f          | f          | f           | f              |            0 |        |
    2 |    0 | (0,294) | 2703 | dup_table         |           11 |       0 |       10 |   403 |        2759 |             0 |        2 |       393 |             0 |             0 | f           | f           | i       | h          |        1 |         0 |           0 |        0 |        0 |       0 | f          | f          | f           | f              |            0 |        |
    (2 rows) 
    ```

    In the above output, the `relfilenode` values for the two rows differ. In these cases, where the rows for duplicate values contain differing system values, additional verification is needed to determine how to correct the problem. See [FIXME2](#fixme2).

7. *If the remaining system column values in the duplicate rows match exactly*, record the `ctid` value of either duplicate row and continue with the next step.

    *If **any** of the remaining system column values in the duplicate rows contain different values*, first follow the instructions in [FIXME2](#fixme2) to determine which of the rows is safe to remove. Continue with the next step only after you have carefully determined which row to remove.